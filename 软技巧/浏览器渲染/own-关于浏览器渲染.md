# 关于浏览器渲染

&emsp;&emsp;从用户输入内容，敲击回车开始，先是浏览器读取本地DNS缓存，如果存在，则直接返回ip地址，如果不存在，则发送请求给本地配置的首选DNS服务器运营商。例如需要查找www.xxx.com的ip地址，运营商接收到该请求，查找自身的DNS库，如果没有找到的话，则把请求发送给根域DNS服务器，每个运营商都有固定的13个根域DNS服务器，如果根域服务器还是没找到，那么根域服务器会把请求发送给.com域服务器，.com服务器查询不到，则会把请求发送给xxx.com域服务器，最后如果在该服务器找到的话，就返回ip地址，否则找不到任何的ip，请求失败；

&emsp;&emsp;获取到ip地址后，将会进行TCP连接，具体是浏览器会用随机端口向服务器的web程序端80端口发起TCP连接请求，这个连接请求到达服务端，需要经过网卡（硬件设备），TCP/IP协议栈解包，最后到达应用层的服务端；

&emsp;&emsp;连接建立后，服务端返回所请求的页面，浏览器要开始进行html的解析工作；解析自顶向下进行，相应的html解析算法有标记化算法和树构造算法，所谓标记化算法的话，指的就是浏览器解析引擎，会读取html文件数据流，通过构造状态机的方式解析和获取数据；一开始文档状态是'数据状态'，一旦遇到'<'，则转换为'标记打开状态'，直到读取到'>'，状态重新变为'数据状态'，在'标记打开状态'读取到的字符会被当做标签名称提供给'树构造算法'，而在'数据状态'中读取的也当作数据传递给'树构造算法'；直到遇到'<'，如果'<'下一个符号是'/'，则状态会转换为'标记结束状态'，直到遇到'>'为止期间的数据流都会当作标签名称传递给'树构造算法'；

&emsp;&emsp;所谓树构造，也就是构造dom树，dom树是由dom节点组成的树，树的结构反映了html文本的dom结构；该算法的输入来自于标记化算法，初始状态是'initial mode',树构造开始于'html'标记的输入，此时状态会转换为'before html'，此时会创建一个HTMLHtmlElement的节点，然后添加到#document根节点去，然后转换为'before head'状态，直到遇到'body'标记，此时会变成'in head'状态，即使流中本来没有head标签，也会创建一个HTMLHeadElement，然后转为'after head'状态，创建一个HTMLBodyElement节点，添加到根节点中，状态变为'in body'，然后接受字符标记，也就是内容，此时会创建一个textnode节点，文本会被添加到该节点中，最后标为'after body'，然后接受html标记，结束文档树构建；

&emsp;&emsp;上面是html解析的主要过程，但是其中还涉及到css，js的解析，所以css，js也有各自的解析；其中，css的解析是当浏览器遇到css标签，或者style标签，就会开始css的解析；css的解析主要是通过构造样式上下文树和规则树，其实规则树的原理还是挺复杂的，我本人现在还是没有太理解，规则树是浏览器用来简化css的计算的，css可以有多种多样的选择器类型，规则树会把其中每次解析后匹配到的路径存放在节点上，下一条css规则过来的时候，先会去已有的规则树上找寻对应路径是否存在，比如div span之类的，就会查看树是否保存了div, span的规则节点，有的话，直接在样式树中添加对应的规则节点，就不需要再重新构造一遍了；

&emsp;&emsp;有了dom节点树和样式树，浏览器会继续构造渲染树，所谓渲染树，也就是最后元素展示在页面上面的样式，渲染树的每一个节点都有自身的样式，包括大小，位置，颜色等等样式，渲染树是在dom节点树和样式树构造时候一同构造的，dom元素和渲染树不是一一对应的，因为有些dom自身是隐藏的，也有一些特殊的标签会有三个或者更多的渲染节点，比如select框；最后，有了渲染树，浏览器会开始着手页面的布局。布局是自上向下，自左向右的，而且后面的元素不会影响已经布局的元素；具体流程是，每一个渲染节点，负责自身和自身所有子节点的布局，元素先放置在指定位置，然后指定自身宽度，然后放置子元素，最后根据所有子元素的总高度，得到自己的高度；

&emsp;&emsp;浏览器使用的是'dirty'标记布局，也就是'脏布局'，当元素的样式发生变化时，该元素及其子元素全部被标记为'dirty'，浏览器会定时检查哪些元素是'dirty'标记的，然后进行重新排列，但是有些样式的修改会涉及到全局的样式重排，例如改变font-size，屏幕大小调整等；父元素布局完成后会把'dirty'标记为false;

&emsp;&emsp;至于js的解析，浏览器会交给js引擎执行，而此时控制权会交给js引擎，因为js可能涉及到dom节点的操作，所以浏览器在脚本执行时候会停止文档的解析，但是如果开发者清楚某个脚本不会影响dom节点，则可以标记脚本为async defer的，此时脚本不会阻塞文档的解析；所以相关的一些优化就是，把js放置在底部，或者添加async或者defer标记；另外，css的解析不会影响dom的构建，但是css的解析结果，可能会被js使用，所以在css解析完成前，浏览器是不会允许脚本解析的，所以css才需要放置在头部，尽快完成其解析；浏览器对js有做过一些优化，例如虽然在js执行期间不会进行dom的解析，但是浏览器还是会把后续文档中所需要的资源预先进行了请求，例如img，pdf等等资源；

&emsp;&emsp;当文档解析完成后，浏览器会标记文档为交互状态，然后解析处于'deferred'的脚本，最后触发'onload'事件;所以，我个人觉得另外一个'DOMHTMLReady'事件是在dom树构造完成后触发的，此时dom树构造完成，但是，样式树，渲染树和其他资源，脚本都是没有准备好的；
