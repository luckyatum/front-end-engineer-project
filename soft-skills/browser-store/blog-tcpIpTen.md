# [关于TCP/IP，必须知道的十个知识点](https://blog.csdn.net/u012371712/article/details/80795297)

![TCP/IP知识点](http://p9.pstatp.com/large/pgc-image/1529747996683fb281bff37)

1. TCP/IP协议模型
    包含了一系列构成互联网基础的网络协议，是internet的核心协议;
    参考模型分为链路层（网络接口层），网络层，传输层，应用层；
    应用层有http，ftp等等协议，传输层则是tcp和udp协议，网络层ip协议，负责对数据加上ip地址和其他数据以确定传输目标，数据链路层，数据包含以太网协议头尾部，为最后的传输做准备；
    数据传输实际就是发送端在每一层为数据不断添加首部，而接收端就是每一层为数据不断拆除首部，以拿到里面的数据；
2. 数据链路层
    数据链路层负责将0，1序列划分为数据帧从一个节点传输到邻近的另一个节点，这些节点通过MAC来唯一标识的；
    封装成帧：把网络层数据报加头和尾，封装成帧，帧头中包括源MAC地址和目标MAC地址；
    透明传输：零比特填充，转义字符；
    可靠传输：出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输；
    差错检测（CRC）：接收者检测错误，如果发现差错，丢弃该帧；
3. 网络层
    * ip协议
    IP协议是TCP/IP的核心，所有的TCP，UDP，ICMP，IGMP数据都以IP数据格式传输，IP是不可靠的协议，也就是Ip协议没有提供一种数据为传达以后的处理机制，因为这被认为是上层协议（TCp/UDP）该做的事情；
    * ARP协议和RARP协议
    ARP协议是IP地址获取MAC地址的一种协议，主机本来是不知道这个IP对应的哪个主机的哪个接口，当主机要发送一个IP包的时候，会先查一下自身的ARP高速缓存（IP-MAC地址对应表缓存），查找不到则向网络发送一个ARP协议广播包，收到该广播的主机会查询自己的ip地址，符合条件的话会把包含自身MAC地址的ARP包传送给发送ARP广播的主机，主机再更新自身缓存；
    RARP协议与ARP协议相反
    * ICMP协议（网络控制协议）
    该协议是IP层的一个保证数据送达的模块协议，当传送IP数据包发生错误，比如主机不可达，路由不可达等等，ICMP会把错误信息封包，传送回主机，给主机一个处理错误的机会；
4. ping
    ping应用可以帮助我们分析和判断网络是否连通，它利用ICMP协议包来侦测另一主机是否可达，原理是用类型码为0的ICMP发请求，收到请求的主机则用类型码为8的ICMP回应；
5. Traceroute
    该工具是用来侦测主机到目的主机之间所经过路由情况的重要工具；
    过程：收到目标主机的IP后，先给目标主机发送一个TTL=1的UDP数据包，而经过第一个路由器收到数据包后，自动把TTL减1（TTL是8字节的，可以记录0-255的数字，每经过一次路由的转发则TTL减1，TTL为0后将终止数据包的转发），此时TTL为0，路由器抛弃该数据包并且返回一个主机不可达的ICMP数据报给主机，主机收到之后再发送一个TTL为2的UDP数据包，然后得到第二个路由器给主机发ICMP数据，以此达到目的主机，然后拿到所有路由器IP；
6. TCP/UDP
    ![TCP/UDP协议](http://p3.pstatp.com/large/pgc-image/15297479967902065f51602)
    * 面向报文
    指的是应用层交给UDP多长报文，UDP就照样发送，所以应用程序必须选择合适大小的报文，如果报文太长，IP层需要分片，降低效率；如果太短，那么ip又会太短；
    * 面向字节流
    虽然应用程序和TCP交互是一次一个数据块，但TCP把应用程序看成是一连串无结构字节流，TCP缓冲会在应用程序数据块过长时候把它划分短一些再传送；
    **TCP相关-HTTP，FTP，TELNET，SMTP;UDP相关-DNS，TFTP，SNMP，NFS**
    * 当对传输数据要求准确，或者面向连接时候，使用TCP，当对网络通讯速度要求尽量快，且对网络通讯质量要求不高的时候，使用UDP；
7. DNS
    域名->ip地址的映射的一个分布式数据库,DNS协议运行在UDP协议和TCP协议上，使用端口53；
8. TCP连接的建立与终止
    * 三次握手
    client发送syn=1，seq=K的请求，client状态至为syn_send，服务端接收到syn=1，发送ack=k+1，seq=J返回，server状态至为syn_rcvd，client接收到返回，然后把seq设置为J+1，同时把数据报文一同发送给server端，然后client和server都进入established状态，完成三次握手
    * 为何要三次握手？
    防止已失效的连接请求报文突然又传送到了server，发送错误；
    如：client发出的第一个请求连接报文段并没有丢失，而是滞留在某个网络节点了，然后在后面某个时间才到达server，server端收到此失效的连接请求报文段后，会向client发送确认报文段，如果不是三次握手，此时server就已经认为连接已经建立了，但是client并没有请求连接，所以server端会一直在等待client发送数据，这样server可能会建立很多没用的连接，耗费资源；