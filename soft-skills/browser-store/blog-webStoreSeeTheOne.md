# [浏览器缓存看这一篇就够了](https://mp.weixin.qq.com/s/q0SGphiRncLldo7CFJO9GQ)


1. 缓存机制
    * 浏览器发送请求前，根据请求头的expires(响应实体报头)和cache-control(请求报头)强策略缓存，判断是否过期，如果命中则读取缓存内容；
    * 如果没有命中，则发送请求，根据last-modified和etag判断是否命中协商缓存，如果命中直接从缓存获取，否则从服务器获取；
2. 强缓存
    * 强缓存不会向服务器请求，而是直接从浏览器缓存读取；
    * 强缓存原理，向浏览器缓存查找请求结果，根据结果的缓存规则决定是否使用该数据,结果情况大致分为以下三种
        * 第一次请求，不存在强缓存，直接请求服务器；
        * 存在缓存标识和结果，但是已经失效，此时请求服务器，然后判断协商缓存；
        * 存在缓存标识和结果且未失效，直接使用；
    * 强缓存规则，浏览器向服务器发起请求时，服务器会将缓存规则放入http响应报文中，和请求结果一起返回给浏览器，控制字段分别是expires和cache-control,后者优先级更高；
    * expires，缓存过期时间，指定资源到期时间，expires=max-age + 请求时间,在过期时间前可以从浏览器缓存读取数据；
    * cache-control，用于控制网页缓存,主要取值如下：
        * public: 所有内容都将被缓存;
        * private: 只有客户端可以缓存内容，默认值；
        * no-cache: 客户端缓存内容，但是是否使用通过协商缓存验证决定
        * no-store: 所有内容都不会被缓存
        * max-age=xxx: 缓存内容在xxx秒后失效
3. 协商缓存
    * 强缓存失效后，浏览器向服务器发起请求，决定是否使用缓存
    * 协商缓存生效，返回304和Not Modified
    * 协商缓存失效，返回200和请求结果
    * last-modified的值在请求后会被缓存起来，下一次请求浏览器会发送if-modified-since: (last-modified的值)，对比是否资源改变了，没有改变的话返回空的正文响应，浏览器读取缓存的值；
    * last-modified以秒为单位，无法捕捉到一秒内的多次修改；各机器读取到的时间不一致，可能会出现误差；
    * etag是http协议提供的一种web缓存验证机制，允许客户端进行缓存协商；etag生成方法通常是使用最近修改的时间戳的哈希值，或者是版本号；
    * etag和last-modified一样，在请求后会由浏览器缓存起来，下次请求头中会带上if-none-match: (缓存的etag的值)，服务端会重新生成etag值，两者对比决定是否资源更新；
    * etag的每次服务端生成都需要读写操作，会耗费比较多的服务器资源，而last-modified只需要读取操作；但是etag的精确度会高于last-modified;
    


