# [页面渲染的完整流程](https://blog.csdn.net/riddle1981/article/details/78681191)

1. 用户输入url并敲击回车
2. 进行DNS解析
   * 浏览器搜索自身DNS缓存，缓存时间比较短，只有2分钟左右，最大1000条缓存；
   * 如果自身找不到，则发去DNS系统调用，向本地配置的首选DNS服务器发起域名解析请求（UDP协议，向53端口发起请求）；
   * 运营商的DNS服务器首先查找自身缓存，没有的话，会代替浏览器发起迭代DNS解析请求；
   * 运营商的DNS向根域DNS的ip地址发起请求（每个DNS服务器都会内置13个根域DNS），请求www.xxx.com的ip地址；
   * 根域服务器即使不知道域名对应地址，但是知道这是.com域的域名，于是把.com域的ip地址返回给运营商，运营商向该ip地址发起请求，请求www.xxx.com的ip地址；
   * .com域的DNS服务器不知道对应地址，但是知道xxx.com域的地址，于是把xxx.com的ip地址返回给运营商，运营商向该ip地址发起请求，请求www.xxx.com的ip地址；
   * 最后在xxx.com域DNS服务器中成功找到对应的ip地址，并且返回；
3. TCP的3次握手
   &emsp;&emsp;拿到域名对应的IP地址之后，User-Agent（一般是指浏览器）会以一个随机端口（1024< 端口 < 65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求（原始的http请求经过TCP/IP4层模型的层层封包）到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。

4. 建立TCP连接后发起http请求
5. 服务器端响应http请求，浏览器得到html代码

---

1. 页面渲染部分
    * 浏览器拿到HTML文档，进行html解析，此时涉及到标记化算法，dom树构造算法；
    * 遇到css样式则开始解析css，构建样式树，样式树是由cssRule对象构成的，每个对象记录了对应的每一条css样式，包括其选择器；
    * 得到dom树和样式树之后，会同步进行渲染树的构建，该树是由渲染节点构成的，目的在于表明元素以怎样的结构进行展示，渲染节点里面包含各种样式属性，位置，大小，颜色等；
    * 渲染树构建完毕后会进行布局，布局使用流模型的layout算法，即后出现的元素不会影响前出现的元素，从左到右，从上到下一遍布局完成；
    * 流布局过程是递归的，每个节点负责自己及其子节点的layout，过程大致如下
        * 父节点确定自己的宽度
        * 父节点完成子节点放置，确定其相对坐标
        * 节点确定自己的宽度和高度
        * 父节点根据所有的子节点高度计算自己的高度
    * 此时渲染树已经构建完毕，此时还需要生成另外一颗树--层树，过程如下；
      * 获取DOM并将其分割为多个层；
      * 将每个层栅格化，独立的绘制进位图中；
      * 将这些位图作为纹理上传至GPU；
      * 复合多个层生成最终屏幕图象；
    * 遇到js标签则会阻塞html解析，此时控制权移交给js引擎，直到js运行完毕，浏览器从中断地方回复DOM构建；
    * 在首绘不需要js的情况下，可以设置script标签为async和defer实现异步加载，这样js不会阻塞html的解析；
    * HTML解析完成后，浏览器标记文档为交互状态，开始解析处于'deferred'模式的脚本，然后文档状态设置为'完成'，触发'onload'事件；

2. css层叠规则
   * 四个位置的值组成的一个组合，用a.b.c.d来表示，当a相同时，比较b，值较大的组合优先级较高，以此类推；
   * 四个位置的值生成规则如下
     * a 如果html标签的style属性中该样式存在，则a = 1；
     * b 选择器中id选择器的个数作为b的值；
     * c 其他属性以及伪类的总数量作为c的值，如'.con'，':hover'等；
     * d 元素名和伪元素的总数量作为d的值，如'div'，':after'等；
   * 注意：* 的组合值为0.0.0.0

3. css解析
   * firefox规则树和样式上下文树
       * 规则树的目的是把css样式表中的规则以树的方式整合起来，树的每一个节点是对应的一条规则，节点上面记录了这条规则的具体内容；
       * 规则树的第一层节点是标签(div、span...)，第二层节点是类名选择器，第三层是id选择器，也就是层数和优先级相关；
       * 所有匹配规则存储在树中，路径中的底层节点拥有较高优先级，规则树包含了所有已知规则匹配的路径；
       * 规则树不会在一开始就为所有节点计算路径，只有当某个节点样式需要进行计算时，才会向规则树添加计算的路径；