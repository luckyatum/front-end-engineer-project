# 【深入浅出docker】第8章-应用的容器化

## 容器化的主要步骤

1. 准备应用代码，也就是要运行在docker容器中的应用；
2. 建立Dockerfile文件，该文件包含了对应用的描述，同时指导Docker完成镜像的构建；
3. 容器化当前应用，构建具体镜像；主要是利用docker image build命令；如：docker image build -t web:latest .
4. 推送本地镜像到仓库，docker login 登陆后，利用命令docker image push luckyatum/web:latest 命令推送镜像到远程仓库；
5. 运行容器，使用命令：docker container run -d --name cl -p 80:8080 web:latest，这样访问docker主机80端口都会转发到应用的8080端口上；

## 详述

* Dockerfile的注释行，都是以#开头的；
* Dockerfile每一行都是一条指令，格式如下：INSTRUCTION argument；
* 指令不区分大小写，但是通常大写以增加可读性；
* docker image build命令会按行执行Dockerfile文件并顺序执行；
* 部分指令会在镜像中创建新的镜像层，如FROM、RUN、COPY等，其他指令只会修改镜像的元数据信息；一个判断指令是否会新增镜像层的基本原则就是：是否向镜像中添加新的文件或者程序；

## 生产阶段

对于镜像来说，越小的体积越好，而在镜像构建过程中，有两种情况可能会增大镜像的体积：

一种是多个RUN指令，每一个指令就会创建一层镜像层，所以尽量合并多条指令，利用 && 连接或者 \ 连接多个命令

另一种是开发者在构建时候会引入大量的构建工具，而在构建完成后有不对其进行清理，也会导致镜像层多了很多不必要的内容；

针对上述问题，有多种解决方案，分别如下：

1. 建造者模式（Builder Pattern）

    建造者模式有两个Dockerfile文件，一个是开发环境，一个是生产环境；

    首先编写Dockerfile.dev，基于一个大型镜像，拉取所需的构建工具，并构建应用。然后基于Dockerfile.dev构建一个镜像，并用这个镜像创建一个容器；

    然后编写Dockerfile.prod，基于一个较小镜像开始构建，并从刚才构建的容器中将应用程序相关的部分复制过来；

    方案是可行的，但是构建比较复杂；需要编写额外的脚本才能串联起来；

2. 多阶段构建（Multi-Stage Build）—— Docker 17.05 新增的版本，用于精简生产镜像的构建

    多阶段构建只有一个Dockerfile,包含多个FROM指令，每一个FROM指令都是一个构建阶段；

    重点在于最后的 COPY --from 指令，它从之前的阶段构建的镜像中**仅复制生产所需的应用代码**，而不会复制生产环境不需要的构件；

    这个方案好处是仅需要一个Dockerfile文件，而且不需要编写额外的脚本；

## 最佳实践

    1. 利用构建缓存（镜像层缓存）

        docker image build 命令执行时，当遇到指令中需要创建一个新的镜像层时候，都会检查缓存中是否已经有与该指令对应的镜像层，如果有，即为缓存命中，否则为缓存未命中；

        一旦曾经有过缓存未命中，则不会再判断后续的指令是否存在镜像缓存，因为底层镜像已经不存在了；

        所以尽量将容易发生变化的指令置于Dockerfile后方执行，有利于最大的从缓存镜像中获益；

        使用 --nocache=true 参数可以显式指定不使用缓存；

        **重要：** COPY、ADD指令执行的时候，例如 COPY ./src ，有可能Dockerfile中的src文件夹内容已经发生变化，而./src路径并没有变化，为了应对这种情况，Docker会计算每一个被复制文件的Checksum值，并与缓存镜像层中同一文件的Checksum值进行比较，如果不匹配，则会认为缓存无效并构建新的镜像层；

    2. 合并镜像

        并非一个最佳实践；

        Docker构建镜像的时候，会正常地构建，但之后会增加一个额外的步骤，将所有内容合并到一个镜像中；

        优点是当镜像中层数太多时，合并简化镜像层是一个优化；缺点则是合并的镜像无法共享镜像层，这会导致存储空间的低效利用；

        docker image build 的时候，可以使用 --squash 参数来创建一个合并的镜像；

## 应用的容器化——命令

* docker image build 命令会读取Dockerfile，并将应用程序容器化；-t 参数可以为镜像打标签， -f 参数可以指定Dockerfile的路径和名称，构建上下文指应用文件存放的位置；
* Docekrfile的FROM指令用于指定要构建的镜像的基础镜像；
* Dockerfile的RUN指令用于在镜像中执行命令，会创建新的镜像层；
* Dockerfile的COPY指令用于将文件作为一个新的层添加到镜像中，通常使用COPY指令将应用代码复制到镜像中；
* Dockerfile的EXPOSE指令用于记录应用所使用的网络端口；
* Dockerfile的ENTRYPOINT指令用于指定镜像以容器方式启动后默认运行的程序；
